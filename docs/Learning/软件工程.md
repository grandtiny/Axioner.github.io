# 软件工程

## 1 软件工程概述

### 1.1 软件与软件危机

*   软件发展的三个阶段：50至60年代程序设计阶段；60至70年代程序系统阶段；70年代以后软件工程阶段。
*   软件的概念：软件是计算机系统中与硬件相互依存的另一部分，它包括**程序、数据及其相关文档**的完整集合。(软件=程序+数据+文档）。
    *   **数据**:是使程序能够适当处理信息的数据结构。
    *   **程序**:是能够完成预定功能和性能的可执行指令序列。
    *   **文档**:是开发、使用和维护过程程序所需要的图文资料。
*   软件的特点：1.软件本身的**复杂性**；2.软件的**成本高昂**；3.软件开发**未摆脱手工开发方式**；4.软件维护与硬件有本质差，**维护难度高**；5.软件开发不是传统硬件制造过程；6.软件是一种逻辑实体，**无磨损性**。
*   软件危机的概念：在计算机软件**开发和维护过程中所遇到的一系列严重问题**。
*   软件危机包含两方面内容：1、**如何开发**软件，以满足对软件日益增长的需求；2、**如何维护**数量不断膨胀的已有软件。
*   软件危机的表现：对软件开发成本和进度估算不准确；用户对已完成软件不满意；软件质量不可靠；软件不可维护；没有适当文档资料；软件成本在计算机系统中所占比例逐年上升；软件开发生产率低。
*   软件危机的原因：
    *   **主观原因：**忽视需求分析；轻视软件维护；没有认识到程序只是软件的一部分；没有认识到软件开发只是漫长的软件生命周期中一个比较次要阶段；越到后期引入变动付出代价越高昂。
    *   **客观原因：**软件是逻辑实体、缺乏可见性，管理和控制困难；软件不会磨损，维护意味着修改原来设计，维护困难；软件规模庞大，程序复杂性随规模增加指数上升。

*   消除软件危机的途径：对计算机软件应该有正确**认识**；吸取借鉴人类长期从事各种工程项目积累的原理、概念、技术和方法；积极开发和使用计算机辅助开发工具；探索更好更有效的**管理措施**和手段对开发过程进行控制和管理。

### 1.2 软件工程

*   软件工程定义：采用**工程**的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的**管理技术**和当前能够得到的最好的**技术方法**结合起来，**经济**的开发出**高质量**的软件并**维护**它。
*   软件工程的本质特性：关注大型程序的构造；中心课题是控制复杂性；软件经常变化；开发效率非常重要；开发人员和谐合作是关键；软件需有效支持用户；软件开发者替代其他领域人员创造产品。
*   软件工程基本原理：按**软件生存期分阶段制定计划**并认真实施；坚持进行阶段评审；坚持严格的产品控制；使用现代程序设计技术；结果能够得到清楚的审查；用人少而精；承认不断改进软件工程实践的必要性。
*   软件工程方法学：把在软件生命周期全过程中使用的**一整套技术方法的集合**称为方法学，也称为泛型。
*   软件工程方法学包括三个要素：方法、工具和过程。
    *   **方法**：完成软件开发各项任务的技术方法，回答“**怎么做**”。
    *   **工具**：为运用方法提供的自动或半自动软件工程**支撑环境**。
    *   **过程**：是为了获得高质量软件所需要完成的一系列任务框架，回答“**何时做**”。
*   软件工程方法学分类：**传统方法学(生命周期方法学)**，**面向对象方法学**。
*   软件重用
    *   **知识重用**：使我们能够高效率的开发、维护一个又一个的软件项目。
    *   **方法重用**：帮助我们有章可循的解决各类工程问题。
    *   **软件成分重用**：使我们在需求分析、系统设计和编码事项的过程中能够事半功倍。
*   软件成分重用又可以分为分析结果重用、设计结 果重用和代码重用三个层次。

### 1.3 软件生命周期

*   软件定义
    *   **问题定义**：弄清用户要解决什么问题。
    *   **可行性研究**：上阶段确定问题是否可行。
    *   **需求分析**：为解决这个问题，系统需要具备什么功能。

*   软件开发
    *   **总体设计**：设计软件结构，确定程序由哪些模块组成以及模块间的关系。
    *   **详细设计**：争对每个模块，设计详细规格说明，确定算法和数据结构。
    *   **编码和单元测试**：将详细设计内容用语言实现，并测试每个模块。
    *   **综合测试**：通过各种类型测试使软件达到预定要求。

*   软件维护
    *   **运行维护**：使软件在整个生命周期内保证满足用户需求。

### 1.4 软件过程

*   定义：是为了获得高质量软件所需要完成的一系列任务框架。 通常用软件生命周期模型描述软件过程。
*   软件工程以质量焦点为基础，分过程、方法和工具三个研究层次。
*   瀑布模型
    *   定义：将软件生存周期的各项活动规定为**依照固定顺序连接**的若干阶段工作，最终得到软件产品。
    *   特点：阶段间具有**顺序性和依赖性**；推迟实现；质量保证；每个阶段必须完成规定的文档；每个阶段结束前完成文档审查, 及早改正错误。
    *   优点：强迫开发人员使用规范的方法，严格规定了每个阶段必须提交的文档，要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证。
    *   缺点：在软件开发的初期阶段就要求做出正确、全面、完整的需求分析对许多应用软件来说是极其困难的；在需求分析阶段，当需求确定后，无法及时验证需求是否正确、完整；作为整体开发的瀑布模型，由于不支持产品的演化，缺乏灵活性，对开发过程中很难发现的错误，只有在最终产品运行时才能暴露出来，从而使软件产品难以维护。
    *   改进后的瀑布模型：在瀑布的每一步中加入验证。

*   快速原型模式
    *   定义：快速建立可运行的程序，它完成的功能往往是最终产品功能的一个子集。
    *   优点：开发的软件产品**通常满足用户需求**；软件产品开发基本是线性过程。
    *   缺点：准确原型设计困难；原型理解可能不同；不利于开发人员创新。

*   增量模型
    *   定义：先完成一个系统子集的开发，再按同样的开发步骤增加功能 (系统子集),如 此递增下去直至满足全部系统需求。
    *   优点：短时间内可提交完成部分功能；逐渐增加产品功能， 用户适应产品快。
    *   缺点：增量构件划分以及集成困难；容易退化为边做边改模型。
    *   风险更大。

*   螺旋模型
    *   定义：在每个阶段之前都增加了风险分析过程的快速原型模型，可以看作增加了风险分析的快速原型模型。
    *   优点：利于把软件质量作为软件开发目标；减少测试；维护和开发不分开。
    *   缺点：风险估计困难。

*   喷泉模型
    *   定义：典型的面向对象软件过程模型；体现迭代和无缝的特性。

## 2 可行性研究

### 2.1 可行性研究任务

*   目的：用最小的代价在最小的时间内确定问题是否能够解决。
*   实质：系统分析和设计过程的大大**压缩和简化**，在**较高层次**上以较为抽象的方式进 行系统的分析和设计过程。
*   过程：分析和澄清问题定义；导出系统的逻辑模型（数据流图+数据字典）；根据逻辑模型探索若干种可供选择解法；研究每种解法可行性。
    *   经济可行性：经济效益是否大于开发成本。
    *   技术可行性：现有技术能否实现。
    *   操作可行性：系统操作方式是否可行。
    *   其他可行性:法律、社会效益。

### 2.2可行性研究内容

*   步骤
    *   **复查系统规模和目标**：对问题定义阶段初步确定的规模和目标进行**肯定或改正**，并列出对目标系统的**约束和限制**。
    *   **研究目前正在使用的系统**：了解现有系统能做什么，而不花费过多时间分析怎么实现这些功能。
    *   **导出新系统的高层逻辑模型**：现有物理系统-现有逻辑模型-目标逻辑模型-目标物理系统。
    *   **进一步定义问题**：分析员和用户一起再次复查系统。前四个步骤构成一个循环。
    *   **导出和评价供选择的解法**：**技术角度**排除不可行方案；**操作可行性**排除用户不能接受方案；**经济可行性**估算成本和收益。
    *   **推荐行动方针**：给出结论。、
    *   **草拟开发计划**：制定进度表；开发人员、计算机资源分析；估计每阶段成本、下阶段详细分析。
    *   **书写文档提交审查**

### 2.3 系统流程图

*   定义：是一种描绘**物理系统**的图，用图形符号以黑盒子形式描绘**物理系统的各部件**，表达数据在系统各部件之间流动的情况。而不是对数据进行加工处理的控制过程。

### 2.4 数据流图与数据字典

*   数据流图（DFD）
    *   定义：描述**信息流和数据**从输入到输出过程所经受的变换。没有任何具体物理部件，只是描绘数据在软件中流动和被处理的**逻辑过程**。
    *   画法：确定系统输入输出、源点以及终点-画系统顶层数据流图-自顶向下分解，画出分层数据流图。

*   数据字典
    *   定义：是关于数据的信息集合，即对数据流图中包含的所有元素定义的集合。
    *   内容：数据流、数据流分量（数据元素）、数据存储、处理。
    *   方法：![image-20230628202301894](C:/Users/Axioner/AppData/Roaming/Typora/typora-user-images/image-20230628202301894.png)
    *   用途：在软件分析和设计的过程中给人提供关于数据的描述信息。作为分析阶段的工具；估计改变一个数据将产生的影响；是数据库开发的第一步。

### 2.5 成本效益分析

*   目的：从经济角度分析新系统的开发是否能盈利，帮助使用部门正确做出是否投资的决定。
*   成本估计：软件成本 = 每行代码的平均成本*源代码行数；
*   成本/效益分析步骤：估计开发成本、运行费用和新系统带来的经济效益；比较新系统的开发成本和经济效益。
*   成本/效益分析的方法：货币的时间价值F=P(1+i)；投资回收期；纯收入；投资回收率。

## 3 需求分析

### 3.1 需求分析任务

*   确定对系统的综合要求
    *   **功能需求**：系统必须提供的服务功能。
    *   **性能需求**：系统必须满足的约束条件 (响应速度、安全性)。
    *   **可靠性和可用性需求**：可靠性定量、可用性量化。
    *   **出错处理需求**：错误响应机制。
    *   **接口需求**：应用系统与环境通信格式常见用户接口需求、硬件接口需求、软件接口需求、通信接口需求。
    *   **约束**：用户或环境强加的限制条件（工具、语言等）。
    *   逆向需求：系统不应该做什么。
    *   将来可能提出要求：将来可能需要实现的需求。

*   分析系统的数据要求
*   导出系统的逻辑模型
*   修正系统开发计划

### 3.2 与用户沟通获取需求办法

*   访谈
*   面向数据流自顶向下求精
*   简易的应用规格说明技术
*   快速建立软件原型

### 3.3 分析建模与规格说明

*   **模型**：是指为了理解事物而对事物做出的一种抽象，是对事物的一种无歧义的书面描述。
*   模型分类
    *   **数据模型**(实体-联系图）：描绘数据对象及数据对象之间的关系。
    *   **功能模型**（数据流图)：描绘数据在系统中流动时被处理的逻辑过程，指明系统具有的变换数据的功能。
    *   **行为模型**(状态转换图）：描绘系统的各种行为模式在不同状态间转换的方式。

### 3.4 实体联系图与状态转换图

*   实体联系图
    *   实体：描述数据对象。
    *   属性：描述数据对象的性质。
    *   联系：描述数据对象之间的交互方式（1-1，1-N，N-M）。
*   状态转换图
    *   状态：系统的行为模式，包括初态、终态、中间状态。
    *   事件：是指在某个特定时刻发生的事情，即对系统从一个状态转换到另一个状态的事件抽象。
    *   在一张状态图中只能有一个初态 而终态可以有**零至多个**。

### 3.5 其他图形工具

*   层次方框图
    *   表示方式：用树形结构的一系列矩形框，描绘数据的层次结构。
    *   优点：随着结构的逐步精细 对数据结构的描绘也越来越详细。

*   Warnier图
    *   表示方式：用树形结构描绘信息的层次结构。
    *   优点：可以表明信息的逻辑组织，可以表明某类信息出现的条件或是否重复出现。

*   IPO图
    *   表示方式：是输入、处理、 输出图的简称，能够方便地描绘输入数据、对数据的处理和输出数据之间的关系。
    *   优点：简略描绘系统主要算法。

### 3.6 验证软件需求

*   从以下方面验证软件需求的正确性
    *   **一致性**：所有需求必须是一致的，任何一条需求不能和其他需求互相矛盾。
    *   **完整性**：需求必须是完整的，规格说明书应该包括用户需要的每一个功能或性能。
    *   **现实性**：指定的需求应该能用现有的硬件和软件技术可以实现。
    *   **有效性**：必须证明需求是正确有效的，确实能解决用户面对的问题。

*   验证软件需求的方法
    *   验证需求的**一致性**：自然语言描述需求、形式化语言描述需求、用软件工具验证。
    *   验证需求的**现实性**：参照开发经验。
    *   验证需求的**完整性**和**有效性**：建立软件原型。

*   用于需求分析的软件工具：PSL/PSA(问题陈述语言/问题陈述分析程序)系统。

## 4 总体设计

### 4.1 设计过程

*   总体设计：概要设计或初步设计。设计过程包括系统设计阶段和结构设计阶段
*   总体设计的任务：确定系统中每个程序由哪些**模块**组成以及这些模块相互间的关系；**划分出物理元素**，包括程序、文件、数据库、文档等。
*   系统设计阶段
    *   设想供选择的方案: 从数据流图出发，将处理分组，抛弃行不通分组。
    *   选取合理的方案:上一步方案选取低、中、高成本三种方案。
    *   推荐最佳方案：推荐最佳方案，制定详细实现计划。

*   结构设计阶段
    *   功能分解：对数据流图进一步细化，进行功能分解。可以 用IPO图等工具描述细化后每个处理的算法。
    *   设计软件结构：层次图或结构图描绘软件结构，或数据流图导出软件结构。
    *   设计数据库
    *   制定测试计划
    *   书写文档
    *   审查和复审

### 4.2 设计原理

*   **模块**：能够单独命名，由**边界元素限定**的程序元素的序列，是构成程序的基本构件。
*   **模块化**：把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求。
*   **抽象**：抽出事务的本质特性而暂时不考虑它们的细节。
*   **信息隐藏**：指一个模块内包含的信息对于不需要这些信息的模块来说，是不能访问的；主要是指模块的实现细节。
*   **局部化**：指把一些关系密切的软件元素在物理地址上放得彼此靠近，它有助于实现信息隐藏。
*   **模块独立性**：是模块化、抽象、信息隐蔽和局部化概念的直接结果；度量标准为耦合和内聚。
*   耦合
    *   定义：是对一个软件结构内**不同模块之间**互连程序的度量；耦合强度取决于模块接口的复杂程度、通过接口的数据等；**耦合性越高，模块独立性越弱**。
    *   分类（程度从低到高）：**无直接耦合-数据耦合-标记耦合(特征耦合)-控制耦合 -外部耦合-公共耦合**

*   内聚
    *   定义：是用来度量一个**模块内部**各个元素彼此结合的紧密程度的。
    *   分类（从低到高）：**偶然内聚-逻辑内聚-时间内聚-过程内聚-通信内聚-顺序内聚-功能内聚**

### 4.3 启发规则

*   改进软件结构提高模块独立性。
*   模块规模应该适中。
*   深度、宽度、扇入和扇出应适当。
*   **深度**：表示软件结构中控制的层数。
*   **宽度**：软件结构内同一个层次上的模块总数的最大值。
*   **扇出**：一个模块**直接控制（调用）**的模块数目，扇出过大意味着模块过分复杂。 一般一个设计的好的典型系统的平均扇出是3或4，扇出的上限是5到9。
*   扇入：指有多少**上级模块调用它**，扇入大说明上级模块共享该模块的数目多。
*   好的软件结构**顶层扇出比较高**，**中层扇出比较少**，底层扇入到公共的实用模块中，即**底层模块有高扇入**。
*   **作用域**：指受该模块内一个判定**影响**的所有模块的集合。
*   **控制域**：是这个模块**本身以及所有直接或间接从属于**它的模块的集合。
*   模块的作用域应该在控制域之内。
*   降低模块接口的复杂程度。
*   设计单入口单出口的模块。
*   模块功能应该可以预测。

### 4.4 描绘软件结构的层次图形

*   层次图：用方框和连线表示,连线表示上下层的**调用关系**。
*   HIPO图：层次图加编号。
*   结构图：不仅描述调用关系，还描述传递的信息和调用方式；箭头代表调用过程传递的信息。尾部**空心代表数据**，**实心代表控制信息**。

### 4.5 面向数据流设计方法

*   面向数据流设计方法也称为结构化设计方法。
*   数据流图分类
    *   变换流：由输入、变换中心和输出三部分组成。
    *   事务流：在多种事务中选择一个执行。

## 5 详细设计

### 5.1 详细设计的目的任务

*   目的：确定怎样具体地实现所要求的系统。得出对目标的精确描述。
*   任务
    *   **过程设计**：即设计软件体系结构中所包含的每个模块的实现算法。
    *   **数据设计**：设计软件数据结构。
    *   **接口设计**：设计软件内部各模块之间的接口。

### 5.2 结构程序设计

*   定义：只用三种基本的控制结构（顺序选择循环）就能实现任何**单入口单出口**的程序。
*   扩充的控制结构：选择多了case多分支和循环多了do-until。

### 5.3 人机界面设计

*   是接口设计的一个重要的组成部分
*   常见的四个问题：**系统响应时间**（**长度**和**易变性**）、**用户帮助设施**、**出错信息处理**、**命令交互**。

### 5.4 过程设计工具

*   定义：描述程序处理过程的工具。
*   **程序流程图**：又称为程序框图，它是历史最悠久使用最广泛的描述软件设计的方法，然而 它也是用得最混乱的一种方法。
*   **盒图(N-S)**：出于要有一种不允许违背结构程序设计精神的图形工具的考虑。
*   ![image-20230629102317886](C:/Users/Axioner/AppData/Roaming/Typora/typora-user-images/image-20230629102317886.png)
*   **PAD图**：它用二维树形结构的图来表示程序的控制流，将这种图翻译成程序代码比较容易。
*   ![image-20230629102348310](C:/Users/Axioner/AppData/Roaming/Typora/typora-user-images/image-20230629102348310.png)
*   **判定表**：当算法中包含多重嵌套的条件选择时判定表却能够清晰地表示复杂的条件组合与应做的动作之间的对应关系。
*   判定表的组成：左上部列出所有条件，左下部是所有可能的动作；右上部是表示各种条件组合，右下部是和每种条件组合相对应的动作。
*   **判定树**：是判定表的变种，也能清晰地表示复杂的条件组合与应做的动作之间的对应关系。
*   PDL：过程设计语言也叫**伪码**。

### 5.5 程序复杂度定量度量

*   流图中的区域数等于环形复杂度。
*   流图G的环形复杂度**V(G)=E-N+2**，E是流图中边的条数，N是结点数。
*   流图G的环形复杂度**V(G)=P+1**，其中，P是流图中判定结点的数目。

## 6 实现与测试

### 6.1 实现

*   软件测试周期中的**编码**和**测试**统称为实现。
*   实现包括两个方面：语言选择、编码风格（程序内部文档、数据说明、语句构造、输入输出、效率）。
*   上条的效率主要指**处理机时间和存储器容量**。

### 6.2 软件测试基础

*   软件测试的目标：软件测试是为了发现错误而执行程序的过程。
*   编码阶段进行单元测试；测试阶段进行各种综合测试。
*   软件测试准则
    *   所有测试都应该能**追溯到用户需求**。
    *   应该远在测试之前就指定测试计划。
    *   Pareto原理：80%的错误由20%的模块造成。
    *   应该从“小规模“测试开始，并逐步进行大规模测试。
    *   穷举测试是不可能的。
    *   为了最大可能发现错误，应由独立的第三方担任测试工作。

*   黑盒测试法：将软件看作一个黑盒子，**不考虑其内部结构和处理过程**，只按照规格说明书的规定， 测试软件是否能够正确接收输入数据，产生正确的输出数据。即测试程序是否正确的实现了其功能。又称为“**功能测试**”。
*   白盒测试法：**完全知道程序的内部结构和处理算法**，因此可以将程序看作一个透明的白盒子，根据程序内部的逻辑结构测试程序内部的主要执行通路是否能够按照预定的要求正确工作。又称“**结构测试**”。
*   软件测试的步骤
    *   **单元测试**（模块测试）：将每个模块作为一个单独的实体进行测试。发现的错误编码和详细设计阶段的错误。
    *   **子系统测试**：将模块集成为一个子系统进行测试。着重**测试模块的接口**。
    *   **系统测试**：将子系统组装为一个完整的系统进行测试，子系统测试和系统测试总称为“**集成测试**”。
    *   **验收测试**（确认测试）：在用户的参与下，往往使用实际的数据进行的测试。发现需求说明中的错误。
    *   **平行运行**: 同时运行新开发出来的系统和将被它取代的旧系统，以便比较新旧两个系统的处理结果。

### 6.3 单元测试

*   依据：详细设计文档
*   技术：白盒测试
*   着重点：模块接口、局部数据结构、重要的执行通路、出错处理通路、边界条件

### 6.4 集成测试

*   目标：发现与接口有关的问题
*   实施者：独立的测试机构或第三方人员
*   集成方法：非渐增测试、渐增测试
    *   **自顶向下集成**：从主控模块开始，沿着程序的控制层次自顶向下移动，逐步添加新的模块。
    *   **自底向上集成**：从最底层模块开始组装。

*   **自顶向下与自底向上相结合**的方法：上层模块使用自顶向下方法，下层模块采用自底向上方法。
*   **回归测试**：重新执行已经做过测试的某个子集，以保证程序的变化没有带来非预期的副作用。

### 6.5 确认测试

*   定义：又称**验收测试**，目标是验证软件的**有效性**。
*   **验证**：为了保证软件正确的实现了某个特定要求而进行的一系列活动。
*   **确认**：为了保证软件确实满足了用户需求而进行的一系列活动。
*   **Alpha测试**：用户在开发者的场所，在开发者指导下进行。
*   **Beta测试**：用户在用户场所进行，遇到问题报告给开发者，开发者进行修改。

### 6.6 白盒测试

*   测试用例：测试输入数据和预期的输出结果。
*   测试方案：测试目的、测试用例的集合。
    *   **语句覆盖**:被测试程序中的每条语句至少执行一次。
    *   **判定覆盖**:使得被测程序中每个判定表达式至少获得一次“真”值和“假”值。
    *   **条件覆盖**:使得判定表达式中每个条件的各种可能的值至少出现一次。
    *   **判定/条件覆盖**:使得判定表达式中的每个条件的所有可能取值至少出现一次，并 使每个判定表达式所有可能的结果也至少出现一次。
    *   **条件组合覆盖**:设计足够多的测试用例，使得每个判定表达式中条件的各种可能 的值的组合都至少出现一次。
    *   **路径覆盖**:覆盖被测程序中所有可能的路径。

*   控制结构测试：基本路径测试、条件测试、循环测试。

### 6.7 黑盒测试

*   又称功能测试，着重测试软件的功能。
*   **等价类划分法**：把程序的输入数据集合**按输入条件划分**为若干个等价类，每一个等价类相对于输入条件表示为一组有效或无效的输入，为每一等价类设计一个测试用例。
*   **边界值分析法**：输入等价类和输出等价类的边界就是应该着重测试的程序边界情况。选取的测试数据应该刚好等于、刚好小于、刚好大于边界值。

### 6.8 调试

*   **调试**（也称为纠错）是在测试发现错误之后排除错误的过程。
*   结果：找到了原因，然后改正和排除；没找到原因，猜测一个原因，并设计附加测试用例来验证这个假设。

### 6.9 软件可靠性

*   **软件可靠性**：程序在给定**时间间隔**内，按照规格说明书的规定成功运行的概率。
*   **软件可用性**：程序在给定**时间点**，按照规格说明书的规定成功运行的概率

## 7 维护

### 7.1 软件维护定义

*   定义：是在软件已经交付使用之后，为了改正错误或满足新的需要而修改软 件的过程。
*   分类
    *   **改正性维护**：诊断和改正错误的过程。
    *   **适应性维护**：为了和变化了的环境适当地配合而进行的修改软件的活动。
    *   **完善性维护** ：为了满足在用户提出的增加新功能或修改已有功能的要求和一般性的改进要求。
    *   **预防性维护**

### 7.2 软件维护特点

*   **非结构化维护**：惟一成分是程序代码，那么维护活动从艰苦地评价程序代码开始。
*   **结构化维护**：有完整的软件配置存在，那么维护工作从评价设计文档开始。

### 7.3 软件维护过程

*   **维护组织-维护报告-维护的事件流-保存维护记录-评价维护活动**

### 7.4 软件可维护性

*   定义：维护人员理解、改正、改动或改进这个软件的难易程度。
*   因素
    *   **可理解性**:读者理解软件的难易程度。
    *   **可测试性**:论证程序正确性的容易程度。
    *   **可修改性**:程序容易修改的程度。
    *   **可移植性**:把程序从一种计算环境（硬件配置和操作系统）转移到另一种计算环境的难易程度。
    *   **可重用性**:同一个软件不做修改或稍加改动，就可以在不同环境中多次重复使用。

### 7.5 预防性维护

*   定义：为了提高未来的可维护性或可靠性，而主动地修改软件。

### 7.6 软件再工程过程

*   预防性维护也称为软件再工程
*   **库存目录分析**：分析可能成为预防性维护的对象，在今后数年内继续使用，当前正在成功使用的程序，可能最近的将来要做较大程度的修改或扩充。
*   **文档重构**:：如果一个程序稳定，正在走向生命终点，不必为它再建立文档；只建立系统中当前正在修改的那部分的完整文档；尽量把文档工作减少到必须的最小量。
*   **逆向工程**: 分析程序，以便在比源代码更高的抽象层次上创建出程序的某种描述的过程。
*   **代码重构**: 重构一些编码方式难理解、测试和维护的模块代码。
*   **数据重构**: 对数据体系结构进行修改维护。
*   **正向工程**: 利用现代软件工程概念、原理、技术和方法，重新开发现有的某个应用系统。

## 8 面向对象方法学

### 8.1 面向对象方法学概述

*   概述：按人类习惯的思维方法，以现实世界中客观存在的对象为中心来思考和认识问题。
*   采用的思想方法与原则：抽象、分类、继承、聚合、封装等。
*   **任何客观的事物或实体都是对象**。对象组成客观世界，复杂的对象可以由简单的对象组成。
*   具有相同数据和操作的对象可以归并为一个类（ class），对象是对象类的一个 实例。
*   类可以派生出子类，子类继承父类的全部特性（ 数据和操作），又可以有自己的新特性。子类与父类形成类的层次结构。
*   对象之间通过消息传递相互联系。
*   **面向对象＝对象＋类＋继承 ＋通信**
*   优点
    *   与人类习惯的思维方法一致
    *   稳定性好
    *   可重用性好
    *   较易开发大型软件产品
    *   可维护性好

### 8.2 面向对象概念

*   **对象**：在应用领域中有意义的、与所要解决的问题有关系的任何事物都可以作为对象，包括具体的物理实体 的抽象、人为的概念、任何有明确边界和意义的东西。
*   对象既有静态的属性，又有动态的行为。
*   对象的**属性**：用来描述对象静态特征的一个数据项。
*   对象的**服务**：用来描述对象动态特征（行为）的一个操作序列
*   对象的属性和所有操作封装在一起，构成一个统一体。 属性一般只能通过执行对象的操作来改变。
*   对象的**特点**：以数据为中心；对象是主动的；实现了数据封装；本质上具有并行性；模块独立性好。
*   **类**：具有相同属性和服务的一组对象的集合，它为属于该类的全部对象提供了统一的抽 象描述。
*   **实例**：是某个特定类所描述的一个具体对象。
*   **消息**：对象之间通信的手段，是一个对象要求另一对象执行类中定义的某个操作的规格说明。
*   **方法**：对象所能执行的操作称为方法，也就是类中所定义的服务。方法描述了对象执行的 功能、响应消息的操作。
*   **属性**：属性是对客观世界实体所具有的性质的抽象，是类中所定义的数据。
*   **封装**：封装是把对象的属性和实现操作的代码结合成一个独立的系统单位，并尽可能隐藏 对象的内部细节，对象以外的部分不能直接作用于对象的内部数据（属性），对象 间的通信只能通过明确的消息来进行。
*   **继承**：直接获得已有的性质和特征，而不必重复它们。
*   **父类**：一个类的上层是父类；**子类**：一个类的下层是子类；**超类**：父类的父类为超类。
*   **单继承**：一个类只允许有一个父类，即类等级为树形结构；**多继承**：一个类允许有多个父类。
*   继承的**优点**：使得相似的对象可以共享程序代码和数据结构，大大减少程序中的冗余信息；便于软件修改维护；用户在开发新系统时不必从零开始，可以继承原有相似功能或者从类库中选取需 要的类，再派生新类。
*   **多态性**：指对象根据所接受的消息而做出动作，同样的消息为不同的对象接受时可导致完全不同的行动。
*   **函数重载**：在同一作用域，若干个参数特征不同的函数可以使用相同的函数名。
*   **运算符重载**：同一个运算符可以施加于不同类型的操作数上面。

### 8.3 面向对象建模

*   **模型**：是一组图示符号和组织这些符号的规则，利用它们来定义和描述问题域中的术语和概念。
*   **对象模型**(object model) ：定义实体，描述系统数据，定义“对谁做”。
*   **动态模型**(dynamic model) ：描述系统控制结构, 规定“何时做”。
*   **功能模型**(functional model) ：描述系统功能, 指明系统应“做什么”。

### 8.4 对象模型

*   UML中，对象模型通常由“类图” 组成。
*   类和类之间的联系称为“关系” 。通常分为：**关联、范化、依赖和细化**四种。
*   关联:在类之间画一条连线；聚集：包括共享聚合和组合聚合；范化:继承性的体现；依赖和细化。

### 8.5 动态模型

*   定义：用来描述系统与时间相关的动态行为，从对象的“事件” 和“状态”的角度出发， 表现对象经过相互作用后，随时间改变的不同运算顺序。
*   动态模型包括“**状态图**”和“**事件追踪图**”。

### 8.6 功能模型

*   数据流图和用例图来描述功能模型。
*   **用例建模：定义系统-寻找行为者和用例-描述用例-定义用例之间的关系-确认模型**

### 8.7 三种模型之间的关系

*   三个模型从三个侧面描述了索要开发的系统，它们相互补充、互相配合。使我们对系统的认识更全面；**功能模型指明系统必须做什么；动态模型规定什么时候做；对象模型定义了做事情的实体。**

## 9 软件项目管理

### 9.1 估算软件规模

*   软件项目管理:通过计划、组织和控制等一系列活动，合理地配置和使用各种资源， 以达到既定目标的过程。

*   估算软件规模方法

    *   代码行技术：根据以往开发经验和历史数据，估算实现一个功能所需源代码行数。
        *   优点：代码是所有项目都有的“产品” ,容易计算代码行数。
        *   缺点：源代码为软件配置的一个部分，用来衡量整个软件规模不太合理；不同语言实现同一软件所需代码行数不相同；不适用于非过程语言。

    *   功能点技术：以**功能点**（FP）为单位度量软件规模。

### 9.2 工作量估算

*   工作量估算模型：**静态单变量模型（基本的COCOMO模型）；静态多变量模型（ COCOMO2模型）；动态多变量模型（putnam模型）**。
*   工作量是软件规模的函数,工作量单位通常是**人月(pm)**。

### 9.3 进度计划

*   甘特图(Gantt图)：甘特图是制定进度计划的工具,优点是能形象描述任务分解情况，直观简洁 和容易掌握。
*   工程网络

### 9.4 人员组织

*   软件开发的人员组织方式：民主制程序员组；主程序员组；现代程序员组。

### 9.5 质量保障

*   **软件质量**：软件质量就是“软件与明确地和隐含地定义的需求相一致的程度“。
*   主要**措施**：基于非执行测试（复审或评审）；基于执行测试（软件测试）；程序正确性证明（数学方法）。

### 9.6 软件配置管理

*   **软件配置管理**：在软件生命期内管理变化的一组活动，用来标识、控制、报告变化， 确保适当的实现了变化。
*   **基线**:通过了正式复审的软件配置项，可以作为进一步开发的基础，只有通过正式的变化控制过程才能改变它。
*   软件配置管理**5项任务**:标识对象、版本控制、变化控制、配置审计和状态报告。

### 9.7 能力成熟度模型

*   能力成熟度模型：用于评价软件机构的软件过程能力成熟度模型，用于帮助软件开发机构建立一个有规模的，成熟的软件过程。
*   **五个等级从低到高：初始级、可重复级、已定义级、已管理级、优化级。**

## 10 问题

### 10.1 

*   什么是软件
    *   软件是计算机系统中与硬件相互依存的另一部分，是程序，数据及其相关文档的完整集合。程序：为实现设计的功能和性能要求而编写的指令序列。数据：使指令能够正常操纵信息的数据结构。文档：与程序开发，维护和使用有关的图文资料。
*   什么是软件危机
    *   是指在软件开发和软件维护过程中所存在的一系列严重问题。
*   什么是软件工程
    *   IEEE：将系统化的、规范的、可度量的方法应用于软件的开发、运行和维护的过程；即将工程化方法应用于软件开发和维护过程中。
*   软件工程的基本要素是什么
    *   软件工程包括三要素：方法，工具和过程；
    *   软件工程方法：为软件开发提供了“如何做某项工作的”的技术指南；
    *   软件工程工具：为软件工程方法提供了自动的或半自动的软件支撑环境；
    *   软件工程过程：定义了如何把各种方法和工具进行综合才能使软件开发合理，及时的进行。
*   软件工程的主要原则有哪些
    *   按**软件生存期分阶段制定计划**并认真实施；
    *   坚持进行阶段评审；
    *   坚持严格的产品控制；
    *   使用现代程序设计技术；
    *   结果能够得到清楚的审查；
    *   用人少而精；
    *   承认不断改进软件工程实践的必要性。

### 10.2

*   瀑布模型的主要特点是什么？
    *   接受上一阶段的结果作为本阶段的输入；
    *   利用这一输入实施本阶段应完成的活动；
    *   对本阶段的工作进行评审；
    *   将本阶段的结果作为输出，传递给下一阶段；
    *   适用于需求确定，变更少的项目。
*   原型模型的主要特点是什么？
    *   通过迭代的过程快速建立与用户需求一致的原型；
    *   软件产品开发过程基本是线性顺序进行的。
*   RAD模型的主要特点是什么？
    *   支持多小组并行工作
    *   强调程序构件复用
    *   开发周期短
*   增量模型的主要特点是什么？
    *   融合了瀑布模型的基本成分和演化模型的迭代特征
    *   强调每个增量都发布一个可运行的产品。
*   螺旋模型的主要特点是什么？
    *   瀑布模型和演化模型的结合
    *   增加了风险分析。
*   重用的三个层次？
    *   重用包括知识重用、方法重用、软件成分重用三个层次；
    *   知识重用:使我们能够高效率的开发、维护一个又一个的软件项目；
    *   方法重用:帮助我们有章可循的解决各类工程问题；
    *   软件成分重用:使我们在需求分析、系统设计和编码事项的过程中能够事半功倍。
*   软件成分重用的三个层次？
    *   软件成分重用又可以分为**分析结果重用、设计结果重用和代码重用**三个层次。
    *   **分析结果重用**：在大部或局部雷同的项目中重复地使用已经被前驱项目证明是正确的部分分析结果；
    *   **设计重用**：在开发类同项目的软件，尤其是在软件移植过程中能够极大地减少工作量，提高工作效率；设计结果重用包括体系结构设计重用和详细设计重用两重内涵。
    *   **代码重用** – 最直接的重用 – 包括基于“宏”的重用、基于函数库的重用和基于继承的重用三种不同的方法。

### 10.3

*   基于计算机的系统的基本组成包括什么？
    *   软件、硬件、人员、数据库、文档和过程。
*   可行性研究主要关注哪些方面？
    *   经济可行性 – 技术可行性 – 法律可行性 – 对不同方案进行评估抉择
*   经济效益的度量包括哪三个方面，如何计算？
    *   投入/产出比 • 投资回收期 • 纯收入
*   硬件工程包括哪三个阶段？
    *   计划与定义 – 设计和样机实现 – 生产、销售和售后服务
*   软件工程包括哪三个阶段？
    *   定义 – 开发 – 检验交付与维护阶段
*   应从哪些角度进行系统定义评审？
    *   管理角度 – 技术角度

### 10.4

*   结构化分析要创建哪些模型？
    *   数据说明ER图；加工说明数据流图；控制说明状态转换图；数据字典
*   加工逻辑描述有哪些方法？
    *   结构化语言 • 判定表 • 判定树

### 10.5

*   什么是模块？有哪些特征？
    *   具有相对独立性的，由数据说明、执行语 句等程序对象构成的集合。
    *   特征：输入/输出；功能；内部数据；程序代码
*   什么是模块化？
    *   将整个程序划分为若干个模块，每 个模块用于实现一个特定的功能。
*   什么是信息隐蔽？
    *   模块将自身的内部信息向其他模块 隐藏起来，以避免其他模块不恰当的访问和修改.
*   体系结构设计的原则有哪些？
    *   (1) 降低模块的耦合性，提高模块的内聚性 
    *   (2) 保持适中的模块规模 
    *   (3) 模块应具有高扇入和适当的扇出 
    *   (4) 软件结构中的深度和宽度不宜过大 
    *   (5) 模块的作用域应处于其控制域范围之内 
    *   (6) 尽量降低模块的接口复杂度
*   数据流有哪些类型？如何区分？
    *   变换型数据流（顺序结构）；事务型数据流（加工路径发散）
*   变换流设计的步骤有哪些？
    *   输入、转换、变换、转换、输出
*   事务流设计的步骤有哪些？
    *   外部数据进入系统，被送往事务中心；
    *    – 事务中心接收输入数据，分析确定其类型；
    *    – 根据输入数据类型为其选择一条加工路径
*   详细设计的工具有哪些？
    *   程序流程图；N-S图（盒图）；PAD图（问题分析图）；PDL语言（伪码）。

### 10.6

*   程序设计语言有哪些特性？

    *   程序设计语言的心理特性能够影响编程者心理的语言性能（歧义性 – 简洁性 – 局部性和顺序性）；
    *   工程特性：从软件工程的观点考虑为了满足软件开发项目的需要，程序设计语言应具备的特性（可移植性 – 语言编译器的实现效率 – 开发工具的支持 – 可维护性）；
    *   技术特性。

*   程序设计语言有哪些选择标准？

    *   理论标准和实用标准

*   编码风格体现在哪些方面？

    *   内部文档 – 标识符的命名及说明 – 语句的构造及书写 – 输入/输出

*   程序复杂度的度量方法有哪些？如何计算？

    *   流图G的环形复杂度**V(G)=E-N+2**，E是流图中边的条数，N是结点数。
    *   流图G的环形复杂度**V(G)=P+1**，其中，P是流图中判定结点的数目。
    *   运算符出现的总次数N1及操作 数出现的总次数N2，程序的文本复杂度N＝N1＋N2。
    *   程序图中所有的转移线画 在结点的同一侧，程序的交点复杂度=程序图中交叉点的个数

    

### 10.8

*   对象、属性、操作的概念？
    *   对象（object）:客观世界的实体，是一组属 性以及这组属性上的专用操作的封装体。
    *   属性（attribute）：每个对象都有它自己的属 性值，表示其状态。
    *   操作（operation）：也称方法或服务，规定 了对象的行为，表示对象所能提供的服务。
*   什么是类？
    *   一组具有相同属性和相同操作的对象的集合
*   什么是封装？
    *   一种信息隐蔽技术，用户只能看见对象封装界面上的信息，对象的内部实现对用户是隐蔽的。
*   什么是继承性？
    *   当类A不但具有类B的属性，而且还具有 自己的独特属性时，称类A继承了类B
*   什么是多态性？
    *   多态性是指同一个操作作用于不同的对象上可以 有不同的解释，产生不同的执行结果。
*   什么是消息、方法？
    *   消息用来请求对象执行某一处理或回答某些 信息要求。
    *   方法是类中操作的实现过程
*   用面向对象方法开发软件要建立哪些模型？
    *   对象模型：描述系统的数据结构，是目标 系统中最关键、最基本、最核心的模型
    *   动态模型：描述系统的控制结构
    *   功能模型：描述系统的功能
