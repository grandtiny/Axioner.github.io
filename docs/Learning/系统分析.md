# 系统分析

## 设计原则概念

*   敏捷软件开发中的敏捷原则
    *   ***尽早并持续的交付***有价值的软件以满足顾客需求。
    *   敏捷过程***欢迎需求的变化***，并利用这种变化来提高用户的竞争优势。
    *   ***经常发布***可用的软件，发布间隔可以从几周到几个月，能短则短。
    *   业务人员和开发人员在项目开发过程中应该***每天共同工作***。
    *   以有进取心的人为项目核心，***充分支持信任***他们。
    *   ***可用的软件***是衡量项目进展的主要指标。
    *   敏捷过程倡导***可持续的开发***，领导、团队、用户应该能按照目前步调持续合作下去。
    *   坚持不懈地***追求技术卓越和良好设计***，以增强敏捷能力。
    *   ***以简洁为本***
    *   最好地架构、需求和设计出自***组织团队***
    *   ***定期反思***

*   面向对象设计原则
    *   单一职责原则（SRP）：一个类只负责一个功能 。
    *   开闭原则（OCP）：对扩展开放，对修改关闭。
    *   里氏替换原则（LSP）：能使用基类对象地方一定能使用其子类对象。
    *   接口隔离原则（ISP）：不应该依赖不相关的接口。
    *   依赖倒置原则（DIP）：抽象不应该依赖具体而应该反过来；针对接口而不是实现编程。
    *   组合复用原则（CRP）：复用时尽量使用聚合/组合而不是继承。
    *   迪米特法则（LoD）：尽可能少地与其他软件实体（类/模块/子系统等）发生依赖关系。
    *   KISS原则：保持简单的设计。
    *   DRY原则：在一个系统中，每一项知识必须具有单一、无歧义、权威的表示。

## 代码重构

*   提炼函数：将代码中的逻辑块提炼出来作为函数，其中本地变量没有修改的作为参数传入新函数，有修改的作为函数的返回值。
*   查询替代临时变量：提取出一个用于计算的函数，将这个函数计算所得结果的返回值替代原函数里的临时变量。
*   拆分循环：当一个循环里面参与了两个模块的时候就可以使用拆分循环重构。
*   拆分阶段：拆分逻辑阶段中的计算阶段和渲染阶段。
*   多态取代条件表达式：当类中某个属性具有多态性时，使用工厂函数取代构造函数

## 设计模式

*   单例模式：创建型模式；先创造一个类，这个类有它本身的私有构造函数和一个静态实例，用另外一个类获取这个类的唯一对象。

    *   ```java
        // SingleObject.java
        public class SingleObject {
         
           //创建 SingleObject 的一个对象
           private static SingleObject instance = new SingleObject();
         
           //让构造函数为 private，这样该类就不会被实例化
           private SingleObject(){}
         
           //获取唯一可用的对象
           public static SingleObject getInstance(){
              return instance;
           }
         
           public void showMessage(){
              System.out.println("Hello World!");
           }
        }
        ```

    *   ```java
        //SingletonPatternDemo.java
        public class SingletonPatternDemo {
           public static void main(String[] args) {
         
              //不合法的构造函数
              //编译时错误：构造函数 SingleObject() 是不可见的
              //SingleObject object = new SingleObject();
         
              //获取唯一可用的对象
              SingleObject object = SingleObject.getInstance();
         
              //显示消息
              object.showMessage();
           }
        }
        ```

    *   输出：Hello World！

*   工厂模式：创建型模式；先创建一个共同接口，接着创建所需接口的实体类，创建工厂，生成基于信息生成的对象。

    *   ```java
        //接口Shape.java
        public interface Shape {
           void draw();
        }
        ```

    *   ```java
        //实现类Rectangle.java
        public class Rectangle implements Shape {
         
           @Override
           public void draw() {
              System.out.println("Inside Rectangle::draw() method.");
           }
        }
        ```

        ```java
        //实现类Square.java
        public class Square implements Shape {
         
           @Override
           public void draw() {
              System.out.println("Inside Square::draw() method.");
           }
        }
        ```

        ```java
        //实现类Circle.java
        public class Circle implements Shape {
         
           @Override
           public void draw() {
              System.out.println("Inside Circle::draw() method.");
           }
        }
        ```

    *   ```java
        //工厂类ShapeFactory.java
        public class ShapeFactory {
            
           //使用 getShape 方法获取形状类型的对象
           public Shape getShape(String shapeType){
              if(shapeType == null){
                 return null;
              }        
              if(shapeType.equalsIgnoreCase("CIRCLE")){
                 return new Circle();
              } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
                 return new Rectangle();
              } else if(shapeType.equalsIgnoreCase("SQUARE")){
                 return new Square();
              }
              return null;
           }
        }
        ```

    *   ```java
        //实现FactoryPatternDemo.java
        public class FactoryPatternDemo {
         
           public static void main(String[] args) {
              ShapeFactory shapeFactory = new ShapeFactory();
         
              //获取 Circle 的对象，并调用它的 draw 方法
              Shape shape1 = shapeFactory.getShape("CIRCLE");
         
              //调用 Circle 的 draw 方法
              shape1.draw();
         
              //获取 Rectangle 的对象，并调用它的 draw 方法
              Shape shape2 = shapeFactory.getShape("RECTANGLE");
         
              //调用 Rectangle 的 draw 方法
              shape2.draw();
         
              //获取 Square 的对象，并调用它的 draw 方法
              Shape shape3 = shapeFactory.getShape("SQUARE");
         
              //调用 Square 的 draw 方法
              shape3.draw();
           }
        }
        ```

*   抽象工厂：创建工厂的工厂

    *   ```java
        //接口类Shape.java
        public interface Shape {
           void draw();
        }
        ```

        ```java
        //接口类Color.java
        public interface Color {
           void fill();
        }
        ```

    *   ```java
        //实体类Rectangle.java
        public class Rectangle implements Shape {
         
           @Override
           public void draw() {
              System.out.println("Inside Rectangle::draw() method.");
           }
        }
        ```

        ```java
        //实体类Square.java
        public class Square implements Shape {
         
           @Override
           public void draw() {
              System.out.println("Inside Square::draw() method.");
           }
        }
        ```

        ```java
        //实体类Circle.java
        public class Circle implements Shape {
         
           @Override
           public void draw() {
              System.out.println("Inside Circle::draw() method.");
           }
        }
        ```

        ```java
        //实体类Red.java
        public class Red implements Color {
         
           @Override
           public void fill() {
              System.out.println("Inside Red::fill() method.");
           }
        }
        ```

        ```java
        //实体类Green.java
        public class Green implements Color {
         
           @Override
           public void fill() {
              System.out.println("Inside Green::fill() method.");
           }
        }
        ```

        ```java
        //实体类Blue.java
        public class Blue implements Color {
         
           @Override
           public void fill() {
              System.out.println("Inside Blue::fill() method.");
           }
        }
        ```

    *   ```java
        //创建抽象工厂类创建工厂AbstractFactory.java
        public abstract class AbstractFactory {
           public abstract Color getColor(String color);
           public abstract Shape getShape(String shape);
        }
        ```

    *   ```java
        //创建工厂类ShapeFactory.java
        public class ShapeFactory extends AbstractFactory {
            
           @Override
           public Shape getShape(String shapeType){
              if(shapeType == null){
                 return null;
              }        
              if(shapeType.equalsIgnoreCase("CIRCLE")){
                 return new Circle();
              } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
                 return new Rectangle();
              } else if(shapeType.equalsIgnoreCase("SQUARE")){
                 return new Square();
              }
              return null;
           }
           
           @Override
           public Color getColor(String color) {
              return null;
           }
        }
        ```

        ```java
        //工厂类ColorFactory.java
        public class ColorFactory extends AbstractFactory {
            
           @Override
           public Shape getShape(String shapeType){
              return null;
           }
           
           @Override
           public Color getColor(String color) {
              if(color == null){
                 return null;
              }        
              if(color.equalsIgnoreCase("RED")){
                 return new Red();
              } else if(color.equalsIgnoreCase("GREEN")){
                 return new Green();
              } else if(color.equalsIgnoreCase("BLUE")){
                 return new Blue();
              }
              return null;
           }
        }
        ```

    *   ```java
        //创建工厂创造类FactoryProducer.java
        public class FactoryProducer {
           public static AbstractFactory getFactory(String choice){
              if(choice.equalsIgnoreCase("SHAPE")){
                 return new ShapeFactory();
              } else if(choice.equalsIgnoreCase("COLOR")){
                 return new ColorFactory();
              }
              return null;
           }
        }
        ```

    *   ```java
        //实现AbstractFactoryPatternDemo.java
        public class AbstractFactoryPatternDemo {
           public static void main(String[] args) {
         
              //获取形状工厂
              AbstractFactory shapeFactory = FactoryProducer.getFactory("SHAPE");
         
              //获取形状为 Circle 的对象
              Shape shape1 = shapeFactory.getShape("CIRCLE");
         
              //调用 Circle 的 draw 方法
              shape1.draw();
         
              //获取形状为 Rectangle 的对象
              Shape shape2 = shapeFactory.getShape("RECTANGLE");
         
              //调用 Rectangle 的 draw 方法
              shape2.draw();
              
              //获取形状为 Square 的对象
              Shape shape3 = shapeFactory.getShape("SQUARE");
         
              //调用 Square 的 draw 方法
              shape3.draw();
         
              //获取颜色工厂
              AbstractFactory colorFactory = FactoryProducer.getFactory("COLOR");
         
              //获取颜色为 Red 的对象
              Color color1 = colorFactory.getColor("RED");
         
              //调用 Red 的 fill 方法
              color1.fill();
         
              //获取颜色为 Green 的对象
              Color color2 = colorFactory.getColor("GREEN");
         
              //调用 Green 的 fill 方法
              color2.fill();
         
              //获取颜色为 Blue 的对象
              Color color3 = colorFactory.getColor("BLUE");
         
              //调用 Blue 的 fill 方法
              color3.fill();
           }
        }
        ```

*   代理模式：结构性模式

    *   ```java
        //接口Image.java
        public interface Image {
           void display();
        }
        ```

    *   ```java
        //实体类RealImage.java
        public class RealImage implements Image {
         
           private String fileName;
         
           public RealImage(String fileName){
              this.fileName = fileName;
              loadFromDisk(fileName);
           }
         
           @Override
           public void display() {
              System.out.println("Displaying " + fileName);
           }
         
           private void loadFromDisk(String fileName){
              System.out.println("Loading " + fileName);
           }
        }
        ```

        ```java
        //实体类ProxyImage.java
        public class ProxyImage implements Image{
         
           private RealImage realImage;
           private String fileName;
         
           public ProxyImage(String fileName){
              this.fileName = fileName;
           }
         
           @Override
           public void display() {
              if(realImage == null){
                 realImage = new RealImage(fileName);
              }
              realImage.display();
           }
        }
        ```

    *   ```java
        //实现ProxyPatternDemo.java
        public class ProxyPatternDemo {
           
           public static void main(String[] args) {
              Image image = new ProxyImage("test_10mb.jpg");java
         
              // 图像将从磁盘加载
              image.display(); 
              System.out.println("");
              // 图像不需要从磁盘加载
              image.display();  
           }
        }
        ```

*   组合模式：类似于递归的管理文件

    *   ```java
        //创建类Employee.java
        import java.util.ArrayList;
        import java.util.List;
         
        public class Employee {
           private String name;
           private String dept;
           private int salary;
           private List<Employee> subordinates;
         
           //构造函数
           public Employee(String name,String dept, int sal) {
              this.name = name;
              this.dept = dept;
              this.salary = sal;
              subordinates = new ArrayList<Employee>();
           }
         
           public void add(Employee e) {
              subordinates.add(e);
           }
         
           public void remove(Employee e) {
              subordinates.remove(e);
           }
         
           public List<Employee> getSubordinates(){
             return subordinates;
           }
         
           public String toString(){
              return ("Employee :[ Name : "+ name 
              +", dept : "+ dept + ", salary :"
              + salary+" ]");
           }   
        }
        ```

    *   ```java
        //打印CompositePatternDemo.java
        public class CompositePatternDemo {
           public static void main(String[] args) {
              Employee CEO = new Employee("John","CEO", 30000);
         
              Employee headSales = new Employee("Robert","Head Sales", 20000);
         
              Employee headMarketing = new Employee("Michel","Head Marketing", 20000);
         
              Employee clerk1 = new Employee("Laura","Marketing", 10000);
              Employee clerk2 = new Employee("Bob","Marketing", 10000);
         
              Employee salesExecutive1 = new Employee("Richard","Sales", 10000);
              Employee salesExecutive2 = new Employee("Rob","Sales", 10000);
         
              CEO.add(headSales);
              CEO.add(headMarketing);
         
              headSales.add(salesExecutive1);
              headSales.add(salesExecutive2);
         
              headMarketing.add(clerk1);
              headMarketing.add(clerk2);
         
              //打印该组织的所有员工
              System.out.println(CEO); 
              for (Employee headEmployee : CEO.getSubordinates()) {
                 System.out.println(headEmployee);
                 for (Employee employee : headEmployee.getSubordinates()) {
                    System.out.println(employee);
                 }
              }        
           }
        }
        ```

*   策略模式：在主函数直接给出类名，什么类就按什么策略操作。

    *   ```java
        //接口Strategy.java
        public interface Strategy {
           public int doOperation(int num1, int num2);
        }
        ```

    *   ```java
        //实体类OperationAdd.java
        public class OperationAdd implements Strategy{
           @Override
           public int doOperation(int num1, int num2) {
              return num1 + num2;
           }
        }
        ```

        ```java
        //实体类OperationSubtract.java
        public class OperationSubtract implements Strategy{
           @Override
           public int doOperation(int num1, int num2) {
              return num1 - num2;
           }
        }
        ```

        ```java
        //实体类OperationMultiply.java
        public class OperationMultiply implements Strategy{
           @Override
           public int doOperation(int num1, int num2) {
              return num1 * num2;
           }
        }
        ```

    *   ```java
        //创建信息类Context.java
        public class Context {
           private Strategy strategy;
         
           public Context(Strategy strategy){
              this.strategy = strategy;
           }
         
           public int executeStrategy(int num1, int num2){
              return strategy.doOperation(num1, num2);
           }
        }
        ```

    *   ```java
        //实现StrategyPatternDemo.java
        public class StrategyPatternDemo {
           public static void main(String[] args) {
              Context context = new Context(new OperationAdd());    
              System.out.println("10 + 5 = " + context.executeStrategy(10, 5));
         
              context = new Context(new OperationSubtract());      
              System.out.println("10 - 5 = " + context.executeStrategy(10, 5));
         
              context = new Context(new OperationMultiply());    
              System.out.println("10 * 5 = " + context.executeStrategy(10, 5));
           }
        }
        ```

*   观察者模式

    *   ```java
        //创建类Subject.java
        import java.util.ArrayList;
        import java.util.List;
         
        public class Subject {
           
           private List<Observer> observers 
              = new ArrayList<Observer>();
           private int state;
         
           public int getState() {
              return state;
           }
         
           public void setState(int state) {
              this.state = state;
              notifyAllObservers();
           }
         
           public void attach(Observer observer){
              observers.add(observer);      
           }
         
           public void notifyAllObservers(){
              for (Observer observer : observers) {
                 observer.update();
              }
           }  
        }
        ```

    *   ```java
        //创建观察类Observer.java
        public abstract class Observer {
           protected Subject subject;
           public abstract void update();
        }
        ```

    *   ```java
        //创造实体观察类BinaryObserver.java
        public class BinaryObserver extends Observer{
         
           public BinaryObserver(Subject subject){
              this.subject = subject;
              this.subject.attach(this);
           }
         
           @Override
           public void update() {
              System.out.println( "Binary String: " 
              + Integer.toBinaryString( subject.getState() ) ); 
           }
        }
        ```

        ```java
        //实体观察类OctalObserver.java
        public class OctalObserver extends Observer{
         
           public OctalObserver(Subject subject){
              this.subject = subject;
              this.subject.attach(this);
           }
         
           @Override
           public void update() {
             System.out.println( "Octal String: " 
             + Integer.toOctalString( subject.getState() ) ); 
           }
        }
        ```

        ```java
        //实体观察类HexaObserver.java
        public class HexaObserver extends Observer{
         
           public HexaObserver(Subject subject){
              this.subject = subject;
              this.subject.attach(this);
           }
         
           @Override
           public void update() {
              System.out.println( "Hex String: " 
              + Integer.toHexString( subject.getState() ).toUpperCase() ); 
           }
        }
        ```

    *   ```java
        //实现ObserverPatternDemo.java
        public class ObserverPatternDemo {
           public static void main(String[] args) {
              Subject subject = new Subject();
         
              new HexaObserver(subject);
              new OctalObserver(subject);
              new BinaryObserver(subject);
         
              System.out.println("First state change: 15");   
              subject.setState(15);
              System.out.println("Second state change: 10");  
              subject.setState(10);
           }
        }
        ```

## 图

用例模型、活动图、系统顺序图、领域类图、实体关系图、顺序图、设计类图、开闭原则、工厂方法、组合模式
