# 数据结构概念

## 1 绪论

### 1.1 数据结构的基本概念

*   数据：计算机程序加工的原料，信息的载体
*   数据元素、数据项：数据的基本单位；数据元素由若干数据项组成
*   数据对象：相同性质的数据元素的集合
*   数据类型（原子类型、结构类型、**抽象数据类型**）
*   数据结构

    *   逻辑结构：线性结构、非线性结构
    *   存储结构（物理结构）：顺序存储、链式存储、索引存储、散列存储
    *   数据的运算

*   仅描述数据间逻辑关系的结构属于逻辑结构，数据的逻辑结构独立于其存储结构

### 1.2 算法和算法评价

*   算法：对特定问题求解步骤的一种描述

*   算法特性：有穷性、确定性、可行性、输入、输出
*   算法目标：正确性、可读性、健壮性、高效率与低存储
*   算法效率度量：时间复杂度、空间复杂度
*   递归程序的时间复杂度一般按照递推的公式进行展开

## 2 线性表

### 2.1 线性表的定义和基本操作

*   线性表特点：个数有限、逻辑顺序、单个元素，数据类型相同、抽象性
*   基本操作
    *   InitLIst(&L)：初始化表
    *   Length(L)：求表长
    *   LocateElem(L,e)：按值查找
    *   GetElem(L,i)：按位查找
    *   ListInsert(&L,i,e)：插入
    *   ListDelete(&L,i,e)：删除
    *   Empty(L)：判空
    *   DestroyList(&L)：销毁

### 2.2 线性表的顺序表示

*   顺序表特点：表中元素逻辑顺序和物理顺序相同
*   随机存取
*   大题
    *   删除限定条件的唯一值并用特殊位置的值替代：遍历一遍更新唯一特殊值的tag
    *   限定空间复杂度的逆置：进行n/2次的首尾交换
    *   删除限定条件的所有值：1、遍历判断符合条件的值用最后一位替换，并把长度减1；2、用两个标识符，一个遍历判断，一个持续增加不符合的值，最后长度为第二个标识符的大小；（有序时可以标识符合条件的开始位置和结束位置）
    *   删除重复值：用一个数组记录tag，后续遍历到tag为1的则删除
    *   合并多表 
    *   前后互换一部分：前面部分逆置，后面部分逆置，再全部逆置
    *   找主元素：主元素是表中重复超过一半的一个元素，遍历表，将遇到的数字tag标1，后续相同则加1，否则-1，tag为0时标记新的数字为tag并标1，遍历到尾部tag的值≥n/2-1便为主元素

### 2.3 线性表的链式表示

*   单向链表用于**栈和队列**：当插入和删除操作都在链表的一端进行时，它表现出先进后出的的特性，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现出先进先出的特性，对应队列。
*   单向链表用于**哈希表**：链地址法是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。
*   单向链表用于**图**：邻接表是表示图的一种常用方式，在其中，图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。
*   双向链表常用于红黑树、B树这类需要访问父节点的数据结构中、浏览器历史、LRU算法（缓存淘汰算法）
*   循环链表常用于**时间片轮转调度算法**、**数据缓冲区**
*   链表中的节点不强调同种类型的元素
*   需要在某一节点前插时可以依旧进行在该节点后插入，接着交换两个节点的data部分，这样更加高效。
*   删除节点时可以先将后续节点的data部分赋值给本节点，再删除后续节点
*   删除各种性质的链表的节点时需要考虑特殊情况，即链表中只有一个元素的情况、
*   大题
    *   删除链表中某个特殊节点可以设立一个tag节点指向特殊节点的pre节点
    *   需要排序链表中的数据时可以采取复制到数组中用nlogn的排序算法排序完再复制回去，空间换时间
    *    给定两个单链表找两个链表的公共节点：对齐尾部后让长的链表先遍历，到等长时同步遍历找到同一地址即为所求
    *   按某种规则拆分链表可以用标记当前遍历的位数的方法
    *   判断单链表是否有环：设置两个快慢指针，当链表有环时慢指针总能遇上快指针

## 3 栈、队列和数组

### 3.1 栈

*   n个不同元素的进栈，出栈元素不同排列个数有（C^n^~2n~/n+1）种
*   基本操作：
    *   InitStack(&S)：初始化栈
    *   StackEmpty(S)：判空
    *   Push(&S,x)：进栈
    *   Pop(&S,&x)：出栈
    *   GetTop(S,&x)：取栈顶
    *   DestroyStack(&S)：销毁

### 3.2 队列

*   循环队列中进队指针F+1%MaxSize，出队R+1%MaxSize，队长（R+MaxSize-F）%MaxSize
*   区分循环队列中队空或是队满的三种解决方法
    *   最后一个存储单元不存储，只用作判断
    *   数据类型中增加表示元素个数，为0队空为Max队满
    *   增设tag，tag=0时因删除导致首尾指针相等则为队空，tag=1时因插入导致首尾相等则队满
*   基本操作：
    *   InitQueue(&Q)：初始化
    *   QueueEmpty(Q)：判空
    *   EnQueue(&Q,x)：进队
    *   DeQueue(&Q,&x)：出队
    *   GetHead(Q,&x)：读取头元素

*   循环队列中每次增删元素对两个指针的赋值都要对MaxSize取余

### 3.3 栈和队列的应用

*   栈在括号匹配中的应用：左括号进栈，右括号匹配
*   栈在表达式求值中的应用：后缀表达式求结果，转化为后缀表达式时优先级高的运算符先进先出
*   栈在递归中的应用
*   队列在层次遍历中的应用
*   队列在计算机系统中的应用：多用户资源竞争、主机与外部设备速度不匹配

### 3.4 数组和特殊矩阵

*   分清行优先或列优先
*   对称矩阵、三角矩阵、三对角矩阵的压缩
*   稀疏矩阵用三元组

## 4 串

### 4.1 串的定义和实现

*   可以定义空串、空格算特殊字符

*   串的存储结构有定长顺序存储、堆分配存储、块链存储
*   串的基本操作
    *   StrAssign(&T,chars)：赋值
    *   StrCopy(&T,S)：复制
    *   StrEmpty(S)：判空
    *   StrCompare(S,T)：比较长短
    *   StrLength(S)：求长度
    *   SubString(&Sub,S,pos,len)：求字串
    *   Concat(&T,S1,S2)：连接两个串为新串
    *   Index(S,T)：求字串在父串中第一次出现的位置
    *   ClearString(&S)：清空成空串
    *   DestroyString(&S)：销毁

### 串的模式匹配

*   简单模式匹配算法为暴力匹配

*   字符串匹配KMP算法以及改进

    *   先求字串的next数组，手算依据当前比较元素划分为前后部分，当前面部分有部分符合的时候，next[i]=j；代码算法为

        ```c
        //计算next数组的第i个时，先比较字符串中的i-1和next[i-1]是否相同，如果相同则next[i]=next[i-1]+1，如果不同则再比较i-1和next[next[i-1]]，直到比较到字符串首位，还是不相等时next[i]置1，代表字符串从头开始匹配。
        void get_next(SString T,int next){
        	int i=1,j=0;
            next[1]=0;
            while(i<T.length){
                if(j==0||T.ch[i]==T.ch[j]){
                    ++i;++j;
                    next[i]=j;
                }
                else
                    j=next[j];
            }
        }
        ```

    * ```c
        //KMP匹配
        int Index_KMP(SString S,SString T,int next[]){
            int i=1,j=1;
            while(i<=S.length&&j<=T.length){
                if(j==0||S.ch[i]==T.ch[j]){
                    ++i;++j;	//匹配，继续匹配下一项
                }
                else
                    j=next[j];	//不匹配，字串向右移动相对量
            }
            if(j>T.length)
                return i-T.length;	//匹配成功
            else
                return 0;
        }
        ```

    *   进一步优化，优化next数组为nextval

## 树与二叉树

### 5.1 树的基本概念

*   树的基本性质

    *   节点数=所有节点度数+1
    *   度为m的树第i层至多有m^i-1^个节点
    *   高为h的m叉树至多有(m^h^-1)/(m-1)个节点
    *   n个节点的m叉树最小高度为log~m~(n(m-1)+1)的向下取整

### 5.2 二叉树的概念

*   满二叉树、完全二叉树、二叉排序树、平衡二叉树
*   二叉树的性质
    *   非空二叉树的叶节点数=度为2的节点数+1
    *   非空二叉树第k层至多有2^k-1^个节点
    *   高为h的二叉树至多有2^h-1^个节点
    *   完全二叉树中节点i的深度为log~2~i的向下取整
    *   n个节点的完全二叉树高度为log~2~(n+1)的向下取整

### 5.3 二叉树的遍历和线索二叉树

*   二叉树线索化：左子树为空则指向前驱节点，右子树为空则指向后续节点
*   若m是n的祖先，使用后序遍历可以找到从m到n的路径
*   线索二叉树是加上线索后的链表结构，即它是二叉树在计算机内部的一种存储结构，所以是一种物理结构
*   n个节点的二叉树中共有n+1个空指针，所以线索化后线索数为n+1
*   后序线索二叉树不饿能有效解决后续后继的问题
*   大题
    *   非递归求二叉树高度：采用层次遍历的算法，加一个高度的tag和每层最右节点的tag，每次遍历到当层的最右节点高度tag加1
    *   由先序遍历序列和中序遍历序列构造二叉链表：采用递归算法，用先序确定根节点，然后划分左右子树包含的节点，分别根据左右子树的先序节点确定左右子树的根节点，以此类推直至子树只剩下一个节点；其他由遍历序列确定二叉树也是类似算法

### 5.4 树和森林

*   森林表示法：双亲表示法9（数组中的伪指针）、孩子表示法（每个节点都有链表）、孩子兄弟表示法
*   先序遍历森林：访问森林中第一棵树的根节点；先序遍历第一棵树中根节点的子树森林；先序遍历除去第一棵树后剩余的树构成的森林。
*   中序遍历森林：中序遍历森林中第一棵树的根节点的子树森林；遍历根节点；中序遍历除去第一棵树后剩余的树构成的森林。
*   若树中任意两个叶节点都不存在相同双亲，则树中的叶子数才有可能与其对应的二叉树中的叶子数相等
*   给出树的先根与后根就是给出其对应的二叉树的先根与中根，所以可以唯一确定树
*   计算森林中某些特殊节点的个数时采用递归的方法，循环条件和孩子兄弟相关

### 5.5 树与二叉树的应用

*   并查集的基本操作：Initial(S)初始化每个元素为集合;Union(S,root1,Root2)把两个子集并在一起;Find(S,x)查找x所在子集并返回子集根节点;
*   一棵度为m的哈夫曼树只有度为0和m的节点，设度为m的节点有nm个，为0的节点有n0个，节点总数为N=nm+n0，N个节点的哈夫曼树有N-1个分支，所以mxnm=N-1=nm+n0-1
*   判定不等长编码是否具有前缀特性：构造一棵新的二叉树，按哈夫曼树规则依次查询编码，每个编码查询到最后有创造新节点的就符合前缀特性

## 6 图

### 6.1 图的基本概念

*   有n(n-1)/2条边的无向图为简单完全图，n(n-1)条边的有向图为完全图
*   连通、连通图、连通分量；有向图为强连通图、强连通分量
*   非连通的无向图极端情况下是一个完全图和一个孤立点

### 6.2 图的存储及基本操作

*   邻接矩阵法：无向图的邻接矩阵是对称矩阵，可以压缩存储；
*   邻接表法：无向图的存储空间为V+2E、有向图存储空间为V+E
*   十字链表法：只能有向图用
*   邻接多重表
*   基本操作
    *   Adjacent(G,x,y) :判断是否存在边
    *   Neighbors(G,x)：列出节点x邻接的边
    *   InsertVertex(G,x)：插入定点
    *   DeleteVertex(G,x)：删除顶点
    *   AddEdge(G,x,y)：若边不存在，则添加该边
    *   RemoveEdge(G,x,y)：若边存在，则删除边
    *   FirstNeighbor(G,x)：返回顶点x的第一个连接点
    *   NextNeighbor(G,x,y)：返回顶点x的下一个节点（除第一个外，无则返回false）
    *   Get_edge_value(G,x,y)：获取边的权值
    *   Set_edge_value(G,x,y,v)：给边赋值

*   若一个有向图的邻接矩阵的对角线下元素都为0，则该图的拓扑排序必定存在
*   邻接矩阵A，|A^n^(i)(j)|的值为从i到j长度为n的路径数目

### 6.3 图的遍历

*   BFS：广搜从初始节点开始遍历，遍历中未访问过的节点进队并tag置1，直至遍历结束；最坏情况下空间复杂度为|V|，采用邻接表时时间复杂度为|V|+|E|，邻接矩阵时间复杂度为|V|^2^；BFS可以用来求单源最短路径（每次入队距离+1）
*   DFS：深搜为递归遍历每个节点中未访问过的节点；空间复杂度为|V|，邻接矩阵时间复杂度为|V|^2^，邻接表时间复杂度为|V|+|E|
*   若无向图是连通的，则一次遍历便能得到所有节点
*   邻接表表示图时，求两节点所有简单路径可以用深搜，从节点1出发访问到节点2时则输出该搜索路径上的节点

### 6.4 图的应用

*   最小生成树
    *   Prim算法：每次并入已并入节点中权值最小的边，时间复杂度为V^2^，不依赖E
    *   Kruskal算法：当连通分量还大于1时持续并入图中权值最小的边所连的节点；该算法通常使用堆存放边的集合，所以时间复杂度为Elog~2~E
*   最短路径
    *   Dijkstra算法求单源最短路径：两个辅助数组dist（记录从原点到其他点当前最短路径长度）、path（从原点到顶点i之间最短路径的前驱节点，用来追溯路径）；顶点集最开始只有原点，两个辅助数组每次遍历后更新，顶点集并入涉及更新的节点，直到所有顶点都并入了顶点集终止；邻接矩阵和邻接矩阵时间复杂度都为V^2^；权值不能为负数。
    *   Floyd算法求各顶点最短路径：有向图，递推产生一个A^k^方阵，其中 A^k^(i)(j) 表示从 i 到 j 的路径长度，k为路径中包含k个节点；初始化完邻接矩阵后依次将每个节点当作中间节点，当比原来的路径短时则更新，当所有节点都遍历过后终止；时间复杂度为V^2^，允许带负数权值的边，但不允许包含负权值的回路。
*   有向无环图描述表达式：共用一些子式
*   拓扑排序：算法实现：初始化栈后将入度为0的顶点，一个一个出栈，并将栈顶指向的顶点入度-1，入度更新后为0的点入栈，直至结束；邻接表时间复杂度为V+E，邻接矩阵时间复杂度为V^2^
*   关键路径
    *   AOE网：用边表示活动的网络，AOE网的边有权值，AOV的则无，AOE网中仅有一个入度为0的点和一个出度为0的点
    *   事件vk的最早发生事件ve(k)：指从源点v1到vk的最长路径长度，计算一般从后往前算
    *   事件vk的最迟发生时间vl(k)：保证后续事件能发生的最晚发生时间
    *   活动ai的最早开始时间e(i)：活动弧的起点所表示的事件的最早发生时间
    *   活动ai的最迟开始时间l(i)：活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差
    *   ai的最迟开始时间l(i)和最早开始时间e(i)的差额d(i)=e(i)-l(i)
    *   求关键路径的算法步骤
        *   从源点出发，令ve=0，按拓扑有序求其余顶点的最早发生时间ve()，就是从源点开始求Max(ve(j1)+Weight(vj1,vk), ve(j2)+Weight(vj2,vk))，每次计算取最大的为ve
        *   从汇点出发，令vl(汇点)=ve(汇点)，按逆拓扑有序求其余节点的最迟发生时间vl()，就是从终点往回求Min(vl(j1)-Weight(vj1,vk), vl(j2)-Weight(vj2,vk))，每次取最小的为vl
        *   根据各顶点的ve求所有弧的最早开始时间e，等于该弧的起点的顶点的ve
        *   根据各顶点的vl求所有弧的最迟开始时间l，等于该弧的终点的顶点的vl减去该弧持续的时间
        *   求AOE网中所有活动的差额d，找出所有d()=0的活动构成关键路径

*   求最短路径不能判断有向图是否有环
*   对任意的带权连通图，当其权值都不相同时，其最小生成树唯一

## 7 查找

### 7.1 查找的基本概念

*   静态查找不涉及修改

### 7.2 顺序查找和折半查找

*   二分查找的指针变动：舍去后半段时high指针指向mid-1的位置，舍去前半段时low指针指向mid+1的位置，mid指向(low+high)/2（向下取整）

    ```c
    int Binary_Search(SSTable L,ElemType key){
        int low=0,high=L.TableLen-1,mid;
        while(low<=high){
            mid=(low+high)/2;
            if(L.elem[mid]==key)
                return mid;
            else if(L.elem[mid]>key)
                high=mid-1;
            else
                low=mid+1;
        }
        return -1;
    }
    ```

*   分块查找：块内元素可以无序，块间元素有序

### 7.3 树型查找

*   二叉排序树：
*   平衡二叉树：平均查找长度O(log~2~n)，4个插入时的旋转，删除从最小不平衡数开始
*   红黑树的性质

    *   根到叶节点的最长路径不大于最短路径的两倍
    *   有n个内部节点的红黑树高度h≤2log~2~(n+1)

### B树和B+树

*   m阶B树的性质
    *   每个节点至多有m颗子树，即至多含有m-1个关键字
    *   根节点不是叶节点时则至少有两颗子树
    *   除根节点外所有非叶节点至少有m/2的向下取整颗子树，即至少含有m/2的向下取整-1个关键字
    *   B树的高度：一颗n个关键字、阶数为m的B树高度h≥log~m~(n+1)
    *   B树中h+1层至少有2(m/2向下取整)^h-1^个节点，因此h≤log~m/2向下取整~((n+1)/2)+1

*   B树中找节点是在磁盘上进行的，在节点内找关键字是在内存中进行的
*   m阶B+树的性质
    *   每个分支节点最多m颗子树
    *   非叶节点至少两颗子树，其他每个分支节点至少有m/2（向下取整）≤n≤m颗子树
    *   相邻叶节点链接

*   对B树进行增删时要注意所有叶节点都在同一层

### 7.5 散列表

*   散列表的构造方法：直接定址法（ax+b）、除留余数法（x%b）、数字分析法、平方取中法
*   处理冲突的方法：开放定址法（线性探测（+1，-1）、平方探测（+i^2^）、双散列法（两个函数）；拉链法（将每个关键字变成链表）
*   装填因子=表中记录数/散列表长度
*   当给出表常和关键字求函数时，找到不大于表长的最大素数（当函数为x%b时）

### 7.6 总结

每个查找集合中查找成功的数据为n个，查找不成功的数据为n+1个；在所有元素查找几率相同时，综合考虑时所有元素几率为1/n+n+1，分开考虑时成功为1/n，失败为1/n+1

## 8 排序

### 8.1 基本概念

*   拓扑排序不属于内部排序
*   对任意n个关键字排序的比较次数至少为log~2~（n！）的向上取整次

### 8.2 插入排序

*   直接插入排序：时间复杂度最好n最坏n^2^，综合n^2^，稳定。

    ```c
    void InsertSort(ElemType A[],int n){
        int i,j;
        for(i=2;i<=n;i++){
            if(A[i]<A[i-1]){
                A[0]=A[i];//哨兵
                for(j=i-1;A[0]<A[j];--j)
                    A[j+1]=A[j];
                A[j+1]=A[0];
            }
        }
    }
    ```

*   折半插入排序：比较次数为nlog~2~n，比直接插入少，但时间复杂度仍为n^2^，稳定。

```c
void InsertSort(ElemType A[],int n){
    int i,j,low,high,mid;
    for(i=2;i<=n;i++){
        A[0]=A[i];
        low=1;high=i-1;
        while(low<high){
            mid=(low+high)/2;
            if(A[mid]>A[0])
                high=mid-1;
            else
                low=mid+1;
        }
        for(j=i-1;j>=high+1;--j)
            A[j+1]=A[j];
        A[high+1]=A[0];
    }
}
```

*   希尔排序：又称缩小增量排序，把相隔n个增量的元素组成一个子表，第二趟排序取一个更小的n，直至最后n为1；空间复杂度1，时间复杂度约为n^1.3^，最坏n^2^，不稳定。

    ```c
    void ShellSort(ElemType A[],int n){
        int dk,i,j; //A[0]只是暂存单元，不是哨兵，当j<=0时，插入位置已到
        for(dk=n/2;dk>=1;dk=dk/2) //dk是自己确定的增量
            for(i=dk+1;i<=n;++i)
                if(A[i]<A[i-dk]){
                    A[0]=A[i];
                    for(j=i-dk;j>0&&A[0]<A[j];j-=dk)
                        A[j+dk]=A[j];
                    A[j+dk]=A[0]
                }
    }
    ```

*   每趟都能确定一个元素最终位置的有：冒泡排序、简单选择排序、堆排序、快速排序，其中前三者能形成全局有序的子序列，后者能确定枢轴元素的最终位置。

### 8.3 交换排序

*   冒泡排序：有序子序列中的元素全局有序，空间复杂度1，时间复杂度为n^2^，稳定。

    ```c
    void BubbleSort(ElemType A[],int n){
        for(int i=0;i<n-1;i++){
            bool flag=false;
            for(int j=n-1;j>i;j--){
                if(A[j-1]>A[j]){
                    swap(A[j-1],A[j]);
                    flag=true;
                }
            }
            if(flag==false)
                return; //第一趟遍历没有发生元素变化说明该表有序，直接退出
        }
    }
    ```

*   快速排序：基本思想基于分治法，选定一个枢纽将表分为两部分，即让枢纽到最终位置上。递归工作栈最好log~2~n最坏n-1，所以栈深度为n，平均情况下栈深度（空间复杂度）为log~2~n，时间复杂度为nlog~2~n，**快速排序是内部排序中平均性能最优的排序算法**，不产生有序子序列，不稳定。

    ```c
    void QuickSort(ElemType A[],int low,int high){
        if(low<high){
            //Paratiton就是划分操作，将表分为符合条件的两个子表
            int pivotpos=Partition(A,low,high);
            QuickSort(A,low,pivotpos-1);
            QuickSort(A,pivotpos+1,high);
        }
    }
    
    int Paratiton(ElemType A[],int low,int high){
        ElemType pivot=A[low];
        while(low<high){
            while(low<high&&A[high]>=pivot)
                --hight;
            while(low<high&&A[low]<=pivot)
                ++low;
            A[high]=A[low];
        }
        A[low]=pivot;
        return low;
    }
    ```

*   当快速排序中的枢纽每次都能把表分成两个长度相似的子表时，快速排序最快。

*   排序过程中尚未确定位置的所有元素都处理一遍才是一趟，注意快速排序中枢纽能划分出多少个子表，有多少个子表就说明下一趟能确定多少个元素的最终位置。

*   需要双向排序时可以置low指针在头部，high指针在尾部，循环体中排序完一次后更新表长度再进行下一次排序即可完成双向排序

*   利用快速排序算法可以快速找到表中排序第k的元素，每次遍历比较枢纽位置和k位置得出k或者k所在的子表，因此只需要n次排序便能得出结果

### 8.4 选择排序

*   简单选择排序：每一趟都可以确定一个元素的最终位置，空间复杂度1，时间复杂度n^2^，不稳定。

    ```c
    void SelectSort(ElemType A[],int n){
        for(int i=0;i<n-1;i++){
            int min=i;
            for(int j=i+1;j<n;j++)
                if(A[j]<A[min])
                    min=j;
            if(min!=i)
                swap(A[i],A[min]);
    	}
    }
    ```

*   堆排序：定义为父节点大于（小于）所有子节点的完全二叉树；建立堆时的调整时间与树高有关，时间复杂度n；堆排序空间复杂度1，时间复杂度nlog~2~n，不稳定

    ```c
    //建立大根堆
    void BuildMaxHeap(ElemType A[],int len){
        for(int i=len/2;i>0;i--)
            HeadAdjust(A,i,len);
    }
    void HeadAdjust(ElemType A[],int k,int len){
        //以k为根的子树调整
        A[0]=A[k];
        for(int i=2*k;i<=len;i*=2){
            if(i<len&&A[i]<A[i+1])
                i++;
            if(A[0]>=A[i])
                break;
            else{
                A[k]=A[i];
                k=i;
            }
        }
        A[k]=A[0];
    }
    
    //排序算法
    void HeapSort(ElemType A[],int len){
        BUildMaxHeap(A,len);
        for(int i=len;i>1;i--){
            Swap(A[i],A[1]);
            HeadAdjust(A,1,i-1);
        }
    }
    ```

    

### 8.5 归并排序和基数排序

*   归并排序：视作n个子表两两归并，一趟归并排序调用n/2h（向上取整）次merge，整个归并排序需要进行log~2~n（向上取整）趟；空间复杂度n，时间复杂度nlog~2~n，稳定

    ```c
    ElemType *B=(ElemType *)malloc((n+1)*sizeof(ElemType));
    void MErge(ElemType A[],int low,int mid,int high){
        int i,j,k;
        for(k=low;k<=high;k++)
            B[k]=A[k];
        for(i=low,j=mid+1,k=i;i<=mid&&j<=high;k++){
            if(B[i]<=B[j])
                A[k]=B[i++];
            else
                A[k]=B[j++];
        }
        while(i<=mid)
            A[k++]=B[i++];
        while(j<=high)
            A[k++]=B[j++];
    }
    ```

*   一般而言，对于n个元素进行k路归并，趟数m满足m=log~k~N（向上取整）
*   基数排序：分为最高位优先MSD和最低位优先LSD；空间复杂度为r（r个队列），时间上一趟分配需要n，收集需要r，需要进行d趟，所以时间复杂度为d(n+r)，稳定。

### 8.6各种内部排序的比较及应用

*   时间复杂度
    *   n^2^：简单选择排序、直接插入排序、冒泡排序
    *   nlog~2~n：快速排序（最坏时n^2^）、堆排序、2路归并排序

*   空间复杂度
    *   1：直接插入排序、冒泡排序、简单选择排序、希尔排序、堆排序
    *   log~2~n：快速排序
    *   n：2路归并排序

*   稳定性
    *   稳定：直接插入排序、冒泡排序、2路归并排序、基数排序
    *   不稳定：简单选择排序、希尔排序、快速排序、堆排序

*   若n较小，信息量不大时可以用简单选择排序和直接插入排序，信息量大时简单排序较优
*   若初始基本有序，则选用直接插入排序或冒泡排序
*   若n较大，且关键字随机分布时快速排序最快，堆排序所需的辅助空间少于快速排序并且不会出现快速排序最坏情况；要求稳定则采取归并排序（通常和直接插入排序结合用）

### 8.7 外部排序

*   外部排序两个阶段：生成初始归并段（采用内部排序或者置换-选择排序）、多趟归并排序（k叉树、败者树、最佳归并树）
*   外部排序总时间=内部排序总时间+外存信息读写时间+内部归并所需时间
*   使用败者树替代k叉树归并后内部归并的比较次数就和k无关（此时内部归并是在工作区中）
*   生成初始归并段时采用置换-选择排序，减少初始归并段个数，比内部排序算法产生的归并段更长
*   置换-选择排序中的缓存区（工作区）选取最小值用的是败者树
*   最佳归并树：将经过置换-选择排序后长度不等的初始归并段组织成m叉哈夫曼树（m是m路归并）；当初始归并段不足以构成一棵严格k叉树时需要添加长度为0的归并段

